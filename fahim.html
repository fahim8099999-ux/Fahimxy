<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WinGo Telegram Bot Controller</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        :root {
            --primary: #8B5CF6;
            --primary-dark: #7C3AED;
            --secondary: #10B981;
            --danger: #EF4444;
            --warning: #F59E0B;
            --dark: #0F172A;
            --dark-light: #1E293B;
            --text: #F8FAFC;
            --text-secondary: #CBD5E1;
        }

        body {
            background: linear-gradient(135deg, var(--dark) 0%, #1E1B4B 100%);
            color: var(--text);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 30px;
            background: rgba(30, 41, 59, 0.8);
            border-radius: 15px;
            border: 2px solid var(--primary);
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .panel {
            background: rgba(30, 41, 59, 0.8);
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 20px;
            border: 1px solid #334155;
        }

        .panel-title {
            font-size: 1.4rem;
            margin-bottom: 20px;
            color: var(--primary);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .config-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .input-group {
            margin-bottom: 15px;
        }

        .input-group label {
            display: block;
            margin-bottom: 8px;
            color: var(--text-secondary);
        }

        .input-group input {
            width: 100%;
            padding: 12px;
            border: 1px solid #475569;
            border-radius: 8px;
            background: var(--dark-light);
            color: var(--text);
        }

        .btn-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 20px;
        }

        .btn {
            background: var(--primary);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.3s ease;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(139, 92, 246, 0.4);
        }

        .btn-success {
            background: var(--secondary);
        }

        .btn-success:hover {
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4);
        }

        .btn-danger {
            background: var(--danger);
        }

        .btn-danger:hover {
            box-shadow: 0 4px 12px rgba(239, 68, 68, 0.4);
        }

        .btn-warning {
            background: var(--warning);
        }

        .status-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .status-card {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            transition: transform 0.3s ease;
        }

        .status-card:hover {
            transform: translateY(-5px);
        }

        .status-value {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .connected { color: var(--secondary); }
        .disconnected { color: var(--danger); }
        .pending { color: var(--warning); }

        .prediction-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }

        .prediction-card {
            background: linear-gradient(135deg, var(--dark-light) 0%, #312E81 100%);
            padding: 20px;
            border-radius: 10px;
            border: 2px solid var(--primary);
            transition: transform 0.3s ease;
        }

        .prediction-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(139, 92, 246, 0.3);
        }

        .prediction-period {
            font-size: 1.1rem;
            font-weight: bold;
            margin-bottom: 10px;
            color: var(--primary);
        }

        .prediction-result {
            font-size: 1.3rem;
            font-weight: bold;
            margin: 10px 0;
        }

        .win { color: var(--secondary); }
        .loss { color: var(--danger); }
        .waiting { color: var(--warning); }

        .history-container {
            max-height: 400px;
            overflow-y: auto;
        }

        .history-item {
            padding: 15px;
            border-bottom: 1px solid #334155;
            display: grid;
            grid-template-columns: 100px 1fr 1fr 80px;
            gap: 15px;
            align-items: center;
            transition: background 0.3s ease;
        }

        .history-item:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: var(--text-secondary);
        }

        .hidden {
            display: none;
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: var(--secondary);
            color: white;
            padding: 15px 20px;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            transform: translateX(150%);
            transition: transform 0.5s ease;
            z-index: 1000;
        }

        .notification.show {
            transform: translateX(0);
        }

        .notification.error {
            background: var(--danger);
        }

        .channel-list {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #334155;
            border-radius: 8px;
            padding: 10px;
            background: var(--dark-light);
        }

        .channel-item {
            padding: 10px;
            border-bottom: 1px solid #334155;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .channel-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .channel-item.selected {
            background: var(--primary);
            color: white;
        }

        .market-data {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 15px;
            border-left: 4px solid var(--primary);
        }

        .market-numbers {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 10px;
        }

        .market-number {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
            transition: transform 0.3s ease;
        }

        .market-number:hover {
            transform: scale(1.1);
        }

        .number-big { background: var(--primary); }
        .number-small { background: var(--secondary); }
        
        .period-info {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }
        
        .api-status {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            font-size: 0.8rem;
            padding: 5px 10px;
            border-radius: 20px;
            background: rgba(255, 255, 255, 0.1);
            margin-left: 10px;
        }
        
        .api-status.connected {
            color: var(--secondary);
        }
        
        .api-status.error {
            color: var(--danger);
        }
        
        .debug-info {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 10px;
            margin-top: 10px;
            font-size: 0.9rem;
            color: var(--text-secondary);
        }
        
        .debug-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }
        
        .debug-label {
            font-weight: bold;
        }
        
        .debug-value {
            color: var(--primary);
        }
        
        .auto-prediction-status {
            background: var(--secondary);
            color: white;
            padding: 5px 10px;
            border-radius: 20px;
            font-size: 0.8rem;
            margin-left: 10px;
        }

        .timer-display {
            font-size: 1.2rem;
            font-weight: bold;
            color: var(--primary);
            text-align: center;
            margin: 10px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            border: 2px solid var(--primary);
        }

        .period-display {
            font-size: 1.1rem;
            text-align: center;
            margin: 10px 0;
            padding: 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
        }

        .cycle-status {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            text-align: center;
            font-size: 0.9rem;
        }
        
        .prediction-flow {
            display: flex;
            justify-content: space-between;
            margin: 20px 0;
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 10px;
        }
        
        .flow-step {
            text-align: center;
            flex: 1;
            padding: 10px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            margin: 0 5px;
        }
        
        .flow-step.active {
            background: var(--primary);
            color: white;
        }
        
        .flow-step.completed {
            background: var(--secondary);
            color: white;
        }
        
        .prediction-log {
            background: rgba(255, 255, 255, 0.05);
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
            font-size: 0.8rem;
            max-height: 100px;
            overflow-y: auto;
        }
        
        .log-entry {
            margin-bottom: 5px;
            padding: 3px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .period-timeline {
            display: flex;
            justify-content: space-between;
            margin: 20px 0;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
        }
        
        .period-item {
            text-align: center;
            flex: 1;
            padding: 10px;
            border-radius: 8px;
            margin: 0 5px;
            background: rgba(255, 255, 255, 0.1);
        }
        
        .period-item.current {
            background: var(--primary);
            color: white;
            font-weight: bold;
        }
        
        .period-item.predicted {
            background: var(--warning);
            color: white;
        }
        
        .period-item.completed {
            background: var(--secondary);
            color: white;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéØ WinGo Bot Controller</h1>
            <p>Real-time Telegram Bot Prediction System</p>
        </div>

        <!-- Configuration Panel -->
        <div class="panel">
            <h2 class="panel-title">‚öôÔ∏è Bot Configuration</h2>
            <div class="config-grid">
                <div>
                    <div class="input-group">
                        <label for="botToken">Bot Token</label>
                        <input type="text" id="botToken" placeholder="Enter your bot token">
                    </div>
                    <div class="input-group">
                        <label for="adminId">Admin User ID</label>
                        <input type="text" id="adminId" placeholder="Enter admin user ID">
                    </div>
                </div>
                <div>
                    <div class="input-group">
                        <label for="channelUsername">Channel Username</label>
                        <input type="text" id="channelUsername" placeholder="@channelname">
                    </div>
                    <button class="btn" onclick="addChannel()">‚ûï Add Channel</button>
                    
                    <div class="input-group">
                        <label>Selected Channel</label>
                        <div id="selectedChannelDisplay" class="loading">No channel selected</div>
                    </div>
                </div>
            </div>
            <div class="btn-group">
                <button class="btn" onclick="saveConfig()">üíæ Save Config</button>
                <button class="btn btn-success" onclick="startBot()">üöÄ Start Bot</button>
                <button class="btn btn-danger" onclick="stopBot()">üõë Stop Bot</button>
                <button class="btn" onclick="testConnection()">üîç Test Connection</button>
            </div>
        </div>

        <!-- Live Market Data -->
        <div class="panel">
            <h2 class="panel-title">
                üìä Live Market Data
                <span class="auto-prediction-status" id="autoPredictionStatus">AUTO PREDICTION: OFF</span>
                <span id="apiStatus" class="api-status">Checking API...</span>
            </h2>
            
            <!-- Timer Display -->
            <div class="timer-display">
                ‚è∞ Next Prediction In: <span id="nextPredictionTimer">--</span> seconds
            </div>

            <!-- Period Display -->
            <div class="period-display">
                üìÖ Current Period: <span id="currentPeriodDisplay">--</span> |
                üîÆ Next Period: <span id="nextPeriodDisplay">--</span>
            </div>

            <!-- Cycle Status -->
            <div class="cycle-status" id="cycleStatus">
                Bot Status: Stopped
            </div>
            
            <!-- Period Timeline -->
            <div class="period-timeline">
                <div class="period-item completed" id="prevPeriodItem">
                    <div>Previous</div>
                    <div id="prevPeriod">--</div>
                </div>
                <div class="period-item current" id="currentPeriodItem">
                    <div>Current</div>
                    <div id="currentPeriodTimeline">--</div>
                </div>
                <div class="period-item predicted" id="nextPeriodItem">
                    <div>Next Prediction</div>
                    <div id="nextPeriodTimeline">--</div>
                </div>
            </div>
            
            <!-- Prediction Flow Visualization -->
            <div class="prediction-flow">
                <div class="flow-step" id="step1">Wait New Period</div>
                <div class="flow-step" id="step2">Check Result</div>
                <div class="flow-step" id="step3">Send Prediction</div>
                <div class="flow-step" id="step4">Wait Result</div>
            </div>

            <div id="marketDataContainer">
                <div class="loading">Loading market data...</div>
            </div>
            
            <div class="debug-info">
                <div class="debug-row">
                    <span class="debug-label">Current Running Period:</span>
                    <span class="debug-value" id="currentRunningPeriod">--</span>
                </div>
                <div class="debug-row">
                    <span class="debug-label">Next Prediction Period:</span>
                    <span class="debug-value" id="nextPredictionPeriod">--</span>
                </div>
                <div class="debug-row">
                    <span class="debug-label">Last Result Check:</span>
                    <span class="debug-value" id="lastResultCheck">--</span>
                </div>
                <div class="debug-row">
                    <span class="debug-label">Bot Status:</span>
                    <span class="debug-value" id="botStatusDetail">Stopped</span>
                </div>
                <div class="debug-row">
                    <span class="debug-label">Last Action:</span>
                    <span class="debug-value" id="lastAction">--</span>
                </div>
                <div class="debug-row">
                    <span class="debug-label">Last API Period:</span>
                    <span class="debug-value" id="lastApiPeriod">--</span>
                </div>
                <div class="debug-row">
                    <span class="debug-label">Last Prediction Period:</span>
                    <span class="debug-value" id="lastPredictionPeriodDebug">--</span>
                </div>
            </div>
            
            <!-- Prediction Log -->
            <div class="prediction-log" id="predictionLog">
                <div>Prediction Log:</div>
            </div>
        </div>

        <!-- Status Panel -->
        <div class="panel">
            <h2 class="panel-title">üìà System Status</h2>
            <div class="status-grid">
                <div class="status-card">
                    <div class="status-value" id="botStatus">Disconnected</div>
                    <div class="status-label">Bot Status</div>
                </div>
                <div class="status-card">
                    <div class="status-value" id="currentPeriodStatus">--</div>
                    <div class="status-label">Current Period</div>
                </div>
                <div class="status-card">
                    <div class="status-value" id="lastPrediction">--</div>
                    <div class="status-label">Last Prediction</div>
                </div>
                <div class="status-card">
                    <div class="status-value" id="winRate">0%</div>
                    <div class="status-label">Win Rate</div>
                </div>
            </div>
        </div>

        <!-- Live Predictions -->
        <div class="panel">
            <h2 class="panel-title">üéØ Live Predictions</h2>
            <div id="predictionsContainer">
                <div class="loading">No active predictions</div>
            </div>
        </div>

        <!-- History -->
        <div class="panel">
            <h2 class="panel-title">üìã Prediction History</h2>
            <div class="history-container" id="historyContainer">
                <div class="loading">No history available</div>
            </div>
        </div>
    </div>

    <!-- Notification -->
    <div class="notification" id="notification">
        <span id="notificationText">Test notification</span>
    </div>

    <script>
        // Configuration
        let config = {
            botToken: '',
            adminId: '',
            selectedChannel: null,
            isRunning: false,
            timerInterval: null,
            marketDataInterval: null,
            currentDataInterval: null,
            messageIds: {},
            predictions: [],
            marketData: [],
            currentPeriod: null,
            nextPeriod: null,
            remainingSeconds: 60,
            lastPredictionPeriod: null,
            isWaitingForResult: false,
            lastApiPeriod: null,
            predictionLog: [],
            previousPeriod: null
        };

        // API URLs
        const CURRENT_API = 'https://api.bdg88zf.com/api/webapi/GetGameIssue';
        const HISTORY_API = 'https://draw.ar-lottery01.com/WinGo/WinGo_1M/GetHistoryIssuePage.json';

        // DOM Elements
        const botStatusElement = document.getElementById('botStatus');
        const currentPeriodStatusElement = document.getElementById('currentPeriodStatus');
        const lastPredictionElement = document.getElementById('lastPrediction');
        const winRateElement = document.getElementById('winRate');
        const predictionsContainer = document.getElementById('predictionsContainer');
        const historyContainer = document.getElementById('historyContainer');
        const marketDataContainer = document.getElementById('marketDataContainer');
        const selectedChannelDisplay = document.getElementById('selectedChannelDisplay');
        const notificationElement = document.getElementById('notification');
        const notificationTextElement = document.getElementById('notificationText');
        const apiStatusElement = document.getElementById('apiStatus');
        const currentRunningPeriodElement = document.getElementById('currentRunningPeriod');
        const nextPredictionPeriodElement = document.getElementById('nextPredictionPeriod');
        const lastResultCheckElement = document.getElementById('lastResultCheck');
        const botStatusDetail = document.getElementById('botStatusDetail');
        const lastActionElement = document.getElementById('lastAction');
        const autoPredictionStatusElement = document.getElementById('autoPredictionStatus');
        const nextPredictionTimerElement = document.getElementById('nextPredictionTimer');
        const currentPeriodDisplay = document.getElementById('currentPeriodDisplay');
        const nextPeriodDisplay = document.getElementById('nextPeriodDisplay');
        const cycleStatusElement = document.getElementById('cycleStatus');
        const lastApiPeriodElement = document.getElementById('lastApiPeriod');
        const lastPredictionPeriodDebugElement = document.getElementById('lastPredictionPeriodDebug');
        const step1Element = document.getElementById('step1');
        const step2Element = document.getElementById('step2');
        const step3Element = document.getElementById('step3');
        const step4Element = document.getElementById('step4');
        const predictionLogElement = document.getElementById('predictionLog');
        const prevPeriodElement = document.getElementById('prevPeriod');
        const currentPeriodTimelineElement = document.getElementById('currentPeriodTimeline');
        const nextPeriodTimelineElement = document.getElementById('nextPeriodTimeline');

        // Initialize
        function init() {
            loadConfig();
            startMarketDataUpdates();
            startTimerSystem();
            updateFlowVisualization('IDLE');
        }

        // Add log entry
        function addLogEntry(message) {
            const now = new Date();
            const timestamp = now.toLocaleTimeString();
            config.predictionLog.unshift(`${timestamp}: ${message}`);
            
            // Keep only last 10 entries
            if (config.predictionLog.length > 10) {
                config.predictionLog.pop();
            }
            
            // Update UI
            predictionLogElement.innerHTML = '<div>Prediction Log:</div>' + 
                config.predictionLog.map(entry => `<div class="log-entry">${entry}</div>`).join('');
        }

        // Update flow visualization
        function updateFlowVisualization(step) {
            // Reset all steps
            step1Element.className = 'flow-step';
            step2Element.className = 'flow-step';
            step3Element.className = 'flow-step';
            step4Element.className = 'flow-step';
            
            switch(step) {
                case 'WAITING_FOR_NEW_PERIOD':
                    step1Element.className = 'flow-step active';
                    break;
                case 'CHECKING_RESULT':
                    step2Element.className = 'flow-step active';
                    break;
                case 'SENDING_PREDICTION':
                    step3Element.className = 'flow-step active';
                    break;
                case 'WAITING_FOR_RESULT':
                    step4Element.className = 'flow-step active';
                    break;
                case 'IDLE':
                    // All steps inactive
                    break;
            }
        }

        // Update period timeline
        function updatePeriodTimeline() {
            if (config.previousPeriod) {
                prevPeriodElement.textContent = config.previousPeriod;
            }
            if (config.currentPeriod) {
                currentPeriodTimelineElement.textContent = config.currentPeriod;
                currentPeriodStatusElement.textContent = config.currentPeriod;
            }
            if (config.nextPeriod) {
                nextPeriodTimelineElement.textContent = config.nextPeriod;
            }
        }

        // Show notification
        function showNotification(message, type = 'success') {
            notificationTextElement.textContent = message;
            notificationElement.style.background = type === 'success' ? 'var(--secondary)' : 'var(--danger)';
            notificationElement.classList.add('show');
            setTimeout(() => {
                notificationElement.classList.remove('show');
            }, 3000);
        }

        // Update last action
        function updateLastAction(action) {
            const now = new Date();
            lastActionElement.textContent = `${action} at ${now.toLocaleTimeString()}`;
        }

        // Update cycle status
        function updateCycleStatus(status) {
            let statusText = '';
            let statusColor = '';

            switch(status) {
                case 'WAITING_FOR_NEW_PERIOD':
                    statusText = 'Waiting for new period to start';
                    statusColor = 'var(--warning)';
                    updateFlowVisualization('WAITING_FOR_NEW_PERIOD');
                    break;
                case 'CHECKING_RESULT':
                    statusText = 'Checking result of previous period';
                    statusColor = 'var(--primary)';
                    updateFlowVisualization('CHECKING_RESULT');
                    break;
                case 'SENDING_PREDICTION':
                    statusText = 'Sending prediction for current period';
                    statusColor = 'var(--primary)';
                    updateFlowVisualization('SENDING_PREDICTION');
                    break;
                case 'WAITING_FOR_RESULT':
                    statusText = 'Waiting for result of prediction';
                    statusColor = 'var(--warning)';
                    updateFlowVisualization('WAITING_FOR_RESULT');
                    break;
                case 'IDLE':
                    statusText = 'Bot is idle';
                    statusColor = 'var(--text-secondary)';
                    updateFlowVisualization('IDLE');
                    break;
            }

            cycleStatusElement.textContent = `Cycle Status: ${statusText}`;
            cycleStatusElement.style.background = statusColor;
        }

        // Load configuration
        function loadConfig() {
            const savedConfig = localStorage.getItem('wingoBotConfig');
            if (savedConfig) {
                config = {...config, ...JSON.parse(savedConfig)};
                document.getElementById('botToken').value = config.botToken || '';
                document.getElementById('adminId').value = config.adminId || '';
                
                if (config.selectedChannel) {
                    selectedChannelDisplay.textContent = config.selectedChannel.username;
                    selectedChannelDisplay.className = 'connected';
                }
            }
        }

        // Save configuration
        function saveConfig() {
            config.botToken = document.getElementById('botToken').value;
            config.adminId = document.getElementById('adminId').value;
            localStorage.setItem('wingoBotConfig', JSON.stringify(config));
            showNotification('Configuration saved successfully!');
        }

        // Add channel manually
        function addChannel() {
            const channelUsername = document.getElementById('channelUsername').value.trim();
            if (!channelUsername) {
                showNotification('Please enter channel username!', 'error');
                return;
            }

            if (!channelUsername.startsWith('@')) {
                showNotification('Channel username must start with @', 'error');
                return;
            }

            config.selectedChannel = {
                username: channelUsername,
                id: channelUsername
            };

            selectedChannelDisplay.textContent = channelUsername;
            selectedChannelDisplay.className = 'connected';
            
            document.getElementById('channelUsername').value = '';
            showNotification(`Channel ${channelUsername} added successfully!`);
        }

        // Test connection
        async function testConnection() {
            if (!config.botToken) {
                showNotification('Please enter Bot Token!', 'error');
                return;
            }

            try {
                const url = `https://api.telegram.org/bot${config.botToken}/getMe`;
                const response = await fetch(url);
                const data = await response.json();
                
                if (data.ok) {
                    showNotification(`Bot connected: ${data.result.first_name}`);
                } else {
                    showNotification('Bot connection failed!', 'error');
                }
            } catch (error) {
                showNotification('Connection error: ' + error.message, 'error');
            }
        }

        // Start bot
        function startBot() {
            if (!config.botToken) {
                showNotification('Please enter Bot Token first!', 'error');
                return;
            }

            if (!config.selectedChannel) {
                showNotification('Please add a channel first!', 'error');
                return;
            }

            config.isRunning = true;
            botStatusElement.textContent = 'Connected';
            botStatusElement.className = 'status-value connected';
            botStatusDetail.textContent = 'Running - Auto Prediction Active';
            autoPredictionStatusElement.textContent = 'AUTO PREDICTION: ON';
            autoPredictionStatusElement.style.background = 'var(--secondary)';
            
            // Start checking for new periods
            startPeriodChecker();

            showNotification('Bot started successfully! Auto prediction is now ON');
            updateLastAction('Bot started');
            updateCycleStatus('WAITING_FOR_NEW_PERIOD');
            addLogEntry('Bot started - Waiting for new period');
        }

        // Stop bot
        function stopBot() {
            config.isRunning = false;
            if (config.timerInterval) {
                clearInterval(config.timerInterval);
            }
            if (config.marketDataInterval) {
                clearInterval(config.marketDataInterval);
            }
            if (config.currentDataInterval) {
                clearInterval(config.currentDataInterval);
            }
            botStatusElement.textContent = 'Disconnected';
            botStatusElement.className = 'status-value disconnected';
            botStatusDetail.textContent = 'Stopped';
            autoPredictionStatusElement.textContent = 'AUTO PREDICTION: OFF';
            autoPredictionStatusElement.style.background = 'var(--danger)';
            nextPredictionTimerElement.textContent = '--';
            showNotification('Bot stopped!');
            updateLastAction('Bot stopped');
            updateCycleStatus('IDLE');
            addLogEntry('Bot stopped');
        }

        // Start timer system
        function startTimerSystem() {
            updateTimerAndPeriod();
            config.timerInterval = setInterval(updateTimerAndPeriod, 1000);
        }

        // Update timer and period
        function updateTimerAndPeriod() {
            const now = new Date();
            
            // Get UTC time components
            const year = now.getUTCFullYear();
            const month = String(now.getUTCMonth() + 1).padStart(2, '0');
            const day = String(now.getUTCDate()).padStart(2, '0');
            const hour = now.getUTCHours();
            const minute = now.getUTCMinutes();
            const second = now.getUTCSeconds();
            
            // Calculate remaining seconds (60 - current second)
            const remainingSeconds = 60 - second;
            
            // Calculate total minutes since start of day
            const totalMinutes = hour * 60 + minute;
            
            // Period formula: ${y}${m}${d}1000${10001 + minutes}
            const currentPeriod = `${year}${month}${day}1000${10001 + totalMinutes}`;
            
            // Next period (current period + 1)
            const nextPeriod = `${year}${month}${day}1000${10001 + totalMinutes + 1}`;
            
            // Update config
            config.currentPeriod = currentPeriod;
            config.nextPeriod = nextPeriod;
            config.remainingSeconds = remainingSeconds;
            
            // Update UI
            currentPeriodDisplay.textContent = currentPeriod;
            nextPeriodDisplay.textContent = nextPeriod;
            nextPredictionTimerElement.textContent = remainingSeconds;
            currentRunningPeriodElement.textContent = currentPeriod;
            nextPredictionPeriodElement.textContent = nextPeriod;
            
            // Update timeline
            updatePeriodTimeline();
        }

        // Start period checker
        function startPeriodChecker() {
            // Check immediately
            checkForNewPeriod();
            
            // Check every 3 seconds
            config.currentDataInterval = setInterval(checkForNewPeriod, 3000);
        }

        // Check for new period
        async function checkForNewPeriod() {
            if (!config.isRunning) return;
            
            try {
                const response = await fetch(CURRENT_API, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        typeId: 1,
                        language: 0,
                        random: "e7fe6c090da2495ab8290dac551ef1ed",
                        signature: "1F390E2B2D8A55D693E57FD905AE73A7",
                        timestamp: Math.floor(Date.now() / 1000)
                    })
                });
                
                const data = await response.json();
                
                if (data && data.data) {
                    const apiPeriod = data.data.issueNumber;
                    lastApiPeriodElement.textContent = apiPeriod || '--';
                    
                    // If this is a new period
                    if (apiPeriod && apiPeriod !== config.lastApiPeriod) {
                        console.log(`üîÑ API period changed: ${config.lastApiPeriod} -> ${apiPeriod}`);
                        addLogEntry(`New period detected: ${apiPeriod}`);
                        
                        // Store previous period
                        if (config.lastApiPeriod) {
                            config.previousPeriod = config.lastApiPeriod;
                        }
                        
                        config.lastApiPeriod = apiPeriod;
                        
                        // Process the new period
                        await processNewPeriod(apiPeriod);
                    }
                }
            } catch (error) {
                console.error('Error checking for new period:', error);
            }
        }

        // Process new period
        async function processNewPeriod(newPeriod) {
            if (!config.isRunning) return;
            
            try {
                // Step 1: Check result of previous period if exists and waiting for result
                if (config.lastPredictionPeriod && config.isWaitingForResult) {
                    updateCycleStatus('CHECKING_RESULT');
                    addLogEntry(`Checking result for previous period: ${config.lastPredictionPeriod}`);
                    
                    const previousPrediction = config.predictions.find(p => p.period === config.lastPredictionPeriod && p.status === 'WAITING');
                    if (previousPrediction) {
                        await checkAndUpdateResult(config.lastPredictionPeriod, previousPrediction.prediction, previousPrediction.messageId);
                        return; // Wait for checkAndUpdateResult to complete
                    }
                }
                
                // Step 2: If not waiting for result, send prediction immediately
                if (!config.isWaitingForResult) {
                    updateCycleStatus('SENDING_PREDICTION');
                    await sendPredictionForCurrentPeriod(newPeriod);
                }
                
            } catch (error) {
                console.error('Error processing new period:', error);
                addLogEntry(`Error processing period: ${error.message}`);
            }
        }

        // Send prediction for current period
        async function sendPredictionForCurrentPeriod(period) {
            if (!config.isRunning || config.isWaitingForResult) {
                addLogEntry(`Cannot send prediction - Bot not running or waiting for result`);
                return;
            }
            
            try {
                const prediction = generateSmartPrediction();
                
                console.log(`üéØ SENDING prediction for CURRENT period ${period}: ${prediction}`);
                addLogEntry(`Sending prediction for ${period}: ${prediction}`);
                
                const message = formatPredictionMessage(period, prediction, '‚è≥ WAITING');
                const messageId = await sendTelegramMessage(message);
                
                config.messageIds[period] = messageId;
                config.lastPredictionPeriod = period;
                config.isWaitingForResult = true;
                lastPredictionPeriodDebugElement.textContent = period;
                
                config.predictions.push({
                    period: period,
                    prediction: prediction,
                    status: 'WAITING',
                    messageId: messageId,
                    timestamp: new Date()
                });

                updateUI();
                
                showNotification(`PREDICTION sent for period ${period}: ${prediction}`);
                updateLastAction(`Sent prediction for ${period}: ${prediction}`);
                
                // Move to waiting for result state
                updateCycleStatus('WAITING_FOR_RESULT');
                addLogEntry(`Waiting for result of ${period}`);
                
                // Start checking for result after 60 seconds
                setTimeout(() => {
                    checkAndUpdateResult(period, prediction, messageId);
                }, 60000);
                
            } catch (error) {
                console.error('Error sending prediction:', error);
                showNotification('Error sending prediction: ' + error.message, 'error');
                updateLastAction('Prediction send failed');
                addLogEntry(`Prediction failed: ${error.message}`);
                
                // Reset waiting flag if prediction failed
                config.isWaitingForResult = false;
                updateCycleStatus('WAITING_FOR_NEW_PERIOD');
            }
        }

        // Check and update result
        async function checkAndUpdateResult(period, prediction, messageId) {
            try {
                updateCycleStatus('CHECKING_RESULT');
                addLogEntry(`Checking result for ${period}`);
                
                console.log(`üîç Checking result for period: ${period}`);
                
                const actualResult = await getActualResultFromHistory(period);
                
                if (!actualResult) {
                    // Result not available yet, try again in 5 seconds
                    addLogEntry(`Result not available for ${period}, retrying...`);
                    setTimeout(() => {
                        checkAndUpdateResult(period, prediction, messageId);
                    }, 5000);
                    return;
                }
                
                const actualNumber = actualResult.number;
                const actualText = actualResult.text;
                const result = determineWinLoss(prediction, actualNumber);
                
                console.log(`üéØ Result for period ${period}: ${result}`);
                addLogEntry(`Result for ${period}: ${result} (${prediction} vs ${actualText})`);
                
                const updatedMessage = formatResultMessage(period, prediction, actualText, result);
                await editTelegramMessage(messageId, updatedMessage);
                
                const predIndex = config.predictions.findIndex(p => p.period === period);
                if (predIndex !== -1) {
                    config.predictions[predIndex].status = result;
                    config.predictions[predIndex].actual = actualText;
                    config.predictions[predIndex].actualNumber = actualNumber;
                }
                
                // Reset waiting flag so we can send next prediction
                config.isWaitingForResult = false;
                
                updateUI();
                showNotification(`Result: ${result} - ${prediction} vs ${actualText}`);
                updateLastAction(`Result: ${result} for ${period}`);
                
                const now = new Date();
                lastResultCheckElement.textContent = `${result} for ${period} at ${now.toLocaleTimeString()}`;
                
                // ‚úÖ FIXED: Immediately send prediction for current period instead of waiting
                addLogEntry(`Result updated, sending prediction for current period`);
                
                // Get current API period and send prediction immediately
                setTimeout(async () => {
                    try {
                        const response = await fetch(CURRENT_API, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                typeId: 1,
                                language: 0,
                                random: "e7fe6c090da2495ab8290dac551ef1ed",
                                signature: "1F390E2B2D8A55D693E57FD905AE73A7",
                                timestamp: Math.floor(Date.now() / 1000)
                            })
                        });
                        
                        const data = await response.json();
                        
                        if (data && data.data) {
                            const currentApiPeriod = data.data.issueNumber;
                            if (currentApiPeriod && currentApiPeriod !== period) {
                                // Send prediction for current period immediately
                                addLogEntry(`Sending immediate prediction for ${currentApiPeriod} after result check`);
                                await sendPredictionForCurrentPeriod(currentApiPeriod);
                            }
                        }
                    } catch (error) {
                        console.error('Error getting current period after result:', error);
                    }
                }, 1000);
                
            } catch (error) {
                console.error('Result update error:', error);
                addLogEntry(`Result update error: ${error.message}`);
            }
        }

        // Start market data updates
        function startMarketDataUpdates() {
            updateMarketData();
            config.marketDataInterval = setInterval(updateMarketData, 10000);
        }

        // Update market data
        async function updateMarketData() {
            try {
                apiStatusElement.textContent = 'Fetching data...';
                apiStatusElement.className = 'api-status';
                
                const response = await fetch(HISTORY_API);
                const data = await response.json();
                
                if (data && data.data && data.data.list) {
                    const last10Results = data.data.list.slice(0, 10).map(item => {
                        const number = parseInt(item.number);
                        return {
                            number: number,
                            type: number >= 5 ? 'BIG' : 'SMALL',
                            period: item.issueNumber || '--'
                        };
                    });
                    
                    config.marketData = last10Results;
                    updateMarketDataUI();
                    
                    apiStatusElement.textContent = 'Connected';
                    apiStatusElement.className = 'api-status connected';
                } else {
                    apiStatusElement.textContent = 'No data';
                    apiStatusElement.className = 'api-status error';
                }
            } catch (error) {
                console.error('Market data error:', error);
                apiStatusElement.textContent = 'API Error';
                apiStatusElement.className = 'api-status error';
            }
        }

        // Update market data UI
        function updateMarketDataUI() {
            if (config.marketData.length === 0) {
                marketDataContainer.innerHTML = '<div class="loading">No market data available</div>';
                return;
            }

            marketDataContainer.innerHTML = config.marketData.map(item => `
                <div class="market-data">
                    <div><strong>Period:</strong> ${item.period}</div>
                    <div class="market-numbers">
                        <div class="market-number ${item.type === 'BIG' ? 'number-big' : 'number-small'}">
                            ${item.number}
                        </div>
                        <div style="margin-left: 10px; padding: 8px; background: ${item.type === 'BIG' ? 'var(--primary)' : 'var(--secondary)'}; border-radius: 5px;">
                            ${item.type}
                        </div>
                    </div>
                </div>
            `).join('');
        }

        // Generate smart prediction
        function generateSmartPrediction() {
            if (config.marketData.length < 3) {
                return Math.random() > 0.5 ? 'BIG' : 'SMALL';
            }

            const last5 = config.marketData.slice(0, 5);
            let bigCount = 0;
            let smallCount = 0;
            
            last5.forEach(item => {
                if (item.type === 'BIG') bigCount++;
                if (item.type === 'SMALL') smallCount++;
            });
            
            if (bigCount >= 3) return 'SMALL';
            if (smallCount >= 3) return 'BIG';
            
            return Math.random() > 0.5 ? 'BIG' : 'SMALL';
        }

        // Format prediction message
        function formatPredictionMessage(period, prediction, status) {
            return `üéØ *PREDICTION* üéØ

üìä Period: ${period}
üéØ Prediction: ${prediction}
‚è≥ Status: ${status}

üîÆ *Trust The Process*`;
        }

        // Format result message
        function formatResultMessage(period, prediction, actual, result) {
            const emoji = result === 'WIN' ? 'üéâ' : 'üò¢';
            const status = result === 'WIN' ? '‚úÖ WINNER!' : '‚ùå BETTER LUCK NEXT TIME!';
            
            return `üéØ *PREDICTION RESULT* üéØ

üìä Period: ${period}
üéØ Prediction: ${prediction}
üèÜ Actual Result: ${actual}
${emoji} Result: ${result}

${status}`;
        }

        // Get actual result from history
        async function getActualResultFromHistory(period) {
            try {
                const response = await fetch(HISTORY_API);
                const data = await response.json();
                
                if (data && data.data && data.data.list) {
                    const periodData = data.data.list.find(item => 
                        item.issueNumber === period
                    );
                    
                    if (periodData) {
                        const number = parseInt(periodData.number);
                        if (!isNaN(number)) {
                            return {
                                number: number,
                                text: `${number >= 5 ? 'BIG' : 'SMALL'} (${number})`,
                                period: period
                            };
                        }
                    }
                }
                return null;
            } catch (error) {
                console.error('Error getting actual result:', error);
                return null;
            }
        }

        // Determine win/loss
        function determineWinLoss(prediction, actualNumber) {
            const actualResult = actualNumber >= 5 ? 'BIG' : 'SMALL';
            return prediction === actualResult ? 'WIN' : 'LOSS';
        }

        // Send message to Telegram
        async function sendTelegramMessage(message) {
            const url = `https://api.telegram.org/bot${config.botToken}/sendMessage`;
            const response = await fetch(url, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    chat_id: config.selectedChannel.id,
                    text: message,
                    parse_mode: 'Markdown'
                })
            });
            
            const data = await response.json();
            if (!data.ok) {
                throw new Error(data.description || 'Failed to send message');
            }
            return data.result.message_id;
        }

        // Edit Telegram message
        async function editTelegramMessage(messageId, newText) {
            const url = `https://api.telegram.org/bot${config.botToken}/editMessageText`;
            const response = await fetch(url, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    chat_id: config.selectedChannel.id,
                    message_id: messageId,
                    text: newText,
                    parse_mode: 'Markdown'
                })
            });
            
            const data = await response.json();
            if (!data.ok) {
                throw new Error(data.description || 'Failed to edit message');
            }
            return data;
        }

        // Update UI
        function updateUI() {
            if (config.predictions.length > 0) {
                const lastPred = config.predictions[config.predictions.length - 1];
                lastPredictionElement.textContent = `${lastPred.prediction} (${lastPred.status})`;
                
                if (lastPred.status === 'WIN') {
                    lastPredictionElement.className = 'status-value win';
                } else if (lastPred.status === 'LOSS') {
                    lastPredictionElement.className = 'status-value loss';
                } else {
                    lastPredictionElement.className = 'status-value pending';
                }
            }
            
            const wins = config.predictions.filter(p => p.status === 'WIN').length;
            const completed = config.predictions.filter(p => p.status !== 'WAITING').length;
            const winRate = completed > 0 ? Math.round((wins / completed) * 100) : 0;
            winRateElement.textContent = `${winRate}%`;
            
            updatePredictionsDisplay();
            updateHistoryDisplay();
            updatePeriodTimeline();
        }

        // Update predictions display
        function updatePredictionsDisplay() {
            const activePredictions = config.predictions.filter(p => p.status === 'WAITING');
            
            if (activePredictions.length === 0) {
                predictionsContainer.innerHTML = '<div class="loading">No active predictions</div>';
                return;
            }
            
            predictionsContainer.innerHTML = activePredictions.map(pred => `
                <div class="prediction-card">
                    <div class="prediction-period">Period: ${pred.period}</div>
                    <div class="prediction-result">Prediction: ${pred.prediction}</div>
                    <div class="prediction-result waiting">Status: ${pred.status}</div>
                    <div class="prediction-result">Channel: ${config.selectedChannel?.username || 'Unknown'}</div>
                </div>
            `).join('');
        }

        // Update history display
        function updateHistoryDisplay() {
            const completedPredictions = config.predictions.filter(p => p.status !== 'WAITING');
            
            if (completedPredictions.length === 0) {
                historyContainer.innerHTML = '<div class="loading">No history available</div>';
                return;
            }
            
            const recentPredictions = completedPredictions.slice(-10).reverse();
            
            historyContainer.innerHTML = recentPredictions.map(pred => `
                <div class="history-item">
                    <div class="history-period">${pred.period}</div>
                    <div class="history-prediction">${pred.prediction}</div>
                    <div class="history-actual">${pred.actual || '--'}</div>
                    <div class="history-status ${pred.status.toLowerCase()}">${pred.status}</div>
                </div>
            `).join('');
        }

        // Initialize when page loads
        window.onload = init;
    </script>
</body>
</html>